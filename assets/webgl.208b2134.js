const T=(r,s,f)=>{const a=r.createShader(r[f]);return r.shaderSource(a,s),r.compileShader(a),r.getShaderParameter(a,r.COMPILE_STATUS)?a:(console.error(r.getShaderInfoLog(a)),null)},b=(r,s,f,a,n)=>{const i=r.createProgram(),c=T(r,s,"VERTEX_SHADER"),E=T(r,f,"FRAGMENT_SHADER");r.attachShader(i,c),r.attachShader(i,E),r.linkProgram(i),r.getProgramParameter(i,r.LINK_STATUS)||console.error("Could not initialize shaders"),r.deleteShader(c),r.deleteShader(E);const t={data:i,attributes:a.reduce((e,u)=>(e[u]=r.getAttribLocation(i,u),e),{}),uniforms:n.reduce((e,u)=>(e[u]=r.getUniformLocation(i,u),e),{}),use:()=>{r.useProgram(i)},dispose:()=>{r.deleteProgram(i)},getUniform:e=>r.getUniform(i,t.uniforms[e]),setUniform:(e,u,o)=>{switch(u){case"float":r.uniform1f(t.uniforms[e],o);break;case"int":r.uniform1i(t.uniforms[e],o);break;case"bool":r.uniform1f(t.uniforms[e],o);break;case"vec2":r.uniform2fv(t.uniforms[e],o);break;case"ivec2":r.uniform2iv(t.uniforms[e],o);break;case"bvec2":r.uniform2fv(t.uniforms[e],o);break;case"vec3":r.uniform3fv(t.uniforms[e],o);break;case"ivec3":r.uniform3iv(t.uniforms[e],o);break;case"bvec3":r.uniform3fv(t.uniforms[e],o);break;case"vec4":r.uniform4fv(t.uniforms[e],o);break;case"ivec4":r.uniform4iv(t.uniforms[e],o);break;case"bvec4":r.uniform4fv(t.uniforms[e],o);break;case"mat2":r.uniformMatrix2fv(t.uniforms[e],!1,o);break;case"mat3":r.uniformMatrix3fv(t.uniforms[e],!1,o);break;case"mat4":r.uniformMatrix4fv(t.uniforms[e],!1,o);break;case"sampler2D":r.uniform1i(t.uniforms[e],o);break;case"samplerCube":r.uniform1i(t.uniforms[e],o);break}}};return t},d=(r,s,f,a)=>{const n=r.createVertexArray();r.bindVertexArray(n);const i=[];f.forEach(({name:t,data:e,size:u})=>{const o=r.createBuffer();i.push(o),r.bindBuffer(r.ARRAY_BUFFER,o),r.bufferData(r.ARRAY_BUFFER,new Float32Array(e),r.STATIC_DRAW),r.vertexAttribPointer(s.attributes[t],u,r.FLOAT,!1,0,0),r.enableVertexAttribArray(s.attributes[t])});let c=null;a&&(c=r.createBuffer(),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,c),r.bufferData(r.ELEMENT_ARRAY_BUFFER,new Uint16Array(a),r.STATIC_DRAW)),r.bindVertexArray(null),r.bindBuffer(r.ARRAY_BUFFER,null),a&&r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null);const E={vao:n,use:t=>{r.bindVertexArray(E.vao),t(a?a.length:void 0),r.bindVertexArray(null)},dispose:()=>{r.deleteVertexArray(E.vao),i.forEach(t=>{r.deleteBuffer(t)}),r.deleteBuffer(c)}};return E},R=(r,s,f)=>{s.use(a=>{a!=null?r.drawElements(r[f],a,r.UNSIGNED_SHORT,0):r.drawArrays(r[f],r.UNSIGNED_SHORT,0)})},m=(r,s)=>{const f=r.createTexture(),a=new Image;return a.onload=()=>{r.bindTexture(r.TEXTURE_2D,f),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,a),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR_MIPMAP_NEAREST),r.generateMipmap(r.TEXTURE_2D),r.bindTexture(r.TEXTURE_2D,null)},a.src=s,{use(n){r.bindTexture(r.TEXTURE_2D,f),n(),r.bindTexture(r.TEXTURE_2D,null)},set(n){a.src=n},bind(n){r.activeTexture(r[`TEXTURE${n}`]),r.bindTexture(r.TEXTURE_2D,f)},dispose(){r.deleteTexture(f)}}};export{d as a,b as c,R as d,m as l};
