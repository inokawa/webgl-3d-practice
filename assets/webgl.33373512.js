const b=(e,u,n)=>{const a=e.createShader(e[n]);return e.shaderSource(a,u),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS)?a:(console.error(e.getShaderInfoLog(a)),null)},R=(e,u,n,a,s)=>{const i=e.createProgram(),E=b(e,u,"VERTEX_SHADER"),T=b(e,n,"FRAGMENT_SHADER");e.attachShader(i,E),e.attachShader(i,T),e.linkProgram(i),e.getProgramParameter(i,e.LINK_STATUS)||console.error("Could not initialize shaders"),e.deleteShader(E),e.deleteShader(T);let c;if(a.length)c=a.reduce((r,f)=>(r[f]=e.getAttribLocation(i,f),r),{});else{const r=e.getProgramParameter(i,e.ACTIVE_ATTRIBUTES),f={};for(let t=0;t<r;t++){const A=e.getActiveAttrib(i,t);f[A.name]=e.getAttribLocation(i,A.name)}c=f}let m;if(s.length)m=s.reduce((r,f)=>(r[f]=e.getUniformLocation(i,f),r),{});else{const r=e.getProgramParameter(i,e.ACTIVE_UNIFORMS),f={};for(let t=0;t<r;t++){const A=e.getActiveUniform(i,t);f[A.name]=e.getUniformLocation(i,A.name)}m=f}const o={data:i,attributes:c,uniforms:m,use:()=>{e.useProgram(i)},dispose:()=>{e.deleteProgram(i)},getUniform:r=>e.getUniform(i,o.uniforms[r]),setUniform:(r,f,t)=>{switch(f){case"float":e.uniform1f(o.uniforms[r],t);break;case"int":e.uniform1i(o.uniforms[r],t);break;case"bool":e.uniform1f(o.uniforms[r],t);break;case"vec2":e.uniform2fv(o.uniforms[r],t);break;case"ivec2":e.uniform2iv(o.uniforms[r],t);break;case"bvec2":e.uniform2fv(o.uniforms[r],t);break;case"vec3":e.uniform3fv(o.uniforms[r],t);break;case"ivec3":e.uniform3iv(o.uniforms[r],t);break;case"bvec3":e.uniform3fv(o.uniforms[r],t);break;case"vec4":e.uniform4fv(o.uniforms[r],t);break;case"ivec4":e.uniform4iv(o.uniforms[r],t);break;case"bvec4":e.uniform4fv(o.uniforms[r],t);break;case"mat2":e.uniformMatrix2fv(o.uniforms[r],!1,t);break;case"mat3":e.uniformMatrix3fv(o.uniforms[r],!1,t);break;case"mat4":e.uniformMatrix4fv(o.uniforms[r],!1,t);break;case"sampler2D":e.uniform1i(o.uniforms[r],t);break;case"samplerCube":e.uniform1i(o.uniforms[r],t);break}}};return o},d=(e,u,n,a)=>{const s=e.createVertexArray();e.bindVertexArray(s);const i=[];n.forEach(({name:c,data:m,size:o})=>{const r=e.createBuffer();i.push(r),e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,new Float32Array(m),e.STATIC_DRAW),e.vertexAttribPointer(u.attributes[c],o,e.FLOAT,!1,0,0),e.enableVertexAttribArray(u.attributes[c])});let E=null;a&&(E=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,E),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(a),e.STATIC_DRAW)),e.bindVertexArray(null),e.bindBuffer(e.ARRAY_BUFFER,null),a&&e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null);const T={vao:s,use:c=>{e.bindVertexArray(T.vao),c(a?a.length:void 0),e.bindVertexArray(null)},dispose:()=>{e.deleteVertexArray(T.vao),i.forEach(c=>{e.deleteBuffer(c)}),e.deleteBuffer(E)}};return T},_=(e,u,n)=>{u.use(a=>{a!=null?e.drawElements(e[n],a,e.UNSIGNED_SHORT,0):e.drawArrays(e[n],e.UNSIGNED_SHORT,0)})},U=(e,u)=>{const n=e.createTexture(),a=new Image;return a.onload=()=>{e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,a),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_NEAREST),e.generateMipmap(e.TEXTURE_2D),e.bindTexture(e.TEXTURE_2D,null)},a.src=u,{use(s){e.bindTexture(e.TEXTURE_2D,n),s(),e.bindTexture(e.TEXTURE_2D,null)},set(s){a.src=s},bind(s){e.activeTexture(e[`TEXTURE${s}`]),e.bindTexture(e.TEXTURE_2D,n)},dispose(){e.deleteTexture(n)}}};export{d as a,R as c,_ as d,U as l};
